# DHT11-device-driver
DHT11 device driver for Raspberry pi

## 모듈 설명

DHT11은 온습도 센서로 데이터 핀 하나와 3.5v ~ 5v 전원과 GND에 연결해 사용합니다.

아무 GPIO 데이터 핀이나 사용해도 상관은 없지만 편의상 GPIO 26번 핀을 사용하기로 합니다. 그리고 센서와의 통신 결과로는 다음과 같은 크기가 5인 정수형 데이터(`1 Byte`) 배열을 읽어 옵니다.

### DHT11 센서가 읽는 데이터 결과 배열

|0|1|2|3|4|
|--|--|--|--|--|
|습도 High|습도 Low|온도 High|온도 Low|Checksum|


위의 표는 DHT11이 읽은 값을 표로 나타낸 것으로 이 중 `Checksum`은 앞의 데이터들을 모두 더한 값으로 **오류 여부를 판단**하는 기준점 역할을 합니다.

<img width="800" alt="그림 1" src="https://github.com/Jaewon-pro/dht11-device-driver/assets/53341392/13e1d8c6-2ba7-4ed6-8298-1b0a83385a92">

> <그림 1> DHT11 센서 측정 흐름도

그림 1과 같이 라즈베리파이가 센서와 통신을 하기 위해서는 해당 데이터 핀을 Output 모드로 설정하고 전압을 Low ‘0’ 신호로 설정합니다.

그리고 20ms동안 대기한 후, Output으로 high `1` 신호로 변경합니다. Low는 최소 18ms이상이어야 하지만 보수적인 값으로 20ms으로 설정했습니다.

그리고 라즈베리파이를 Input모드로 설정하여 전압을 올리고 30us만큼 대기합니다.

이때, 데이터시트를 참고하면 DHT11의 응답 비트 신호가 계속 High인 경우는 이상 응답이라고 명시되어 있습니다. 그래서 해당 DHT11 드라이버는 `DHT11_check()` 함수를 통해서 반복문을 통해 1us만큼 시간 간격을 주면서 해당 핀에서 읽어온 값이 0인지 1인지 확인합니다.

<img width="800" alt="그림 2" src="https://github.com/Jaewon-pro/dht11-device-driver/assets/53341392/b842a142-bff2-42ba-9489-3cb33fde61ab">

> <그림 2> 시간차에 따른 데이터 차이

만약 읽은 값이 0인 정상적인 값이라면, 이어서 `DHT11_read_bit()` 함수를 호출하여 값을 일정 시간동안 읽습니다.

일정 시간동안 값이 Low인지 High인지 구분하기 위해서 1us간격마다 읽어 들인 핀의 값(High or Low)이 일정한지 확인합니다. 

이때 그림 3을 보면, High 신호가 입력되는 시간이 26 ~ 28us이라면 값이 ‘0’ 이고 70us이라면 ‘1’을 의미합니다. 이렇게 시간에 따른 구분을 위해서 `DHT11_read_bit()` 함수로 같은 비트를 계속 읽는지 확인하고 40us만큼 대기한 뒤, 마지막으로 다시 핀의 값을 한번 읽고 반환합니다. 앞서 언급된 대기 시간들은 DHT11 센서 데이터시트에 명시된 값으로 일정하게 정해진 값입니다.

이렇게 1비트씩 40번, 즉 8비트(1Byte)씩 5번 읽어서 1바이트씩 길이가 5인 온습도 데이터 배열에 저장합니다. 일련의 과정들은 유저레벨에서 이 모듈의 `read()` 함수를 호출한다면 동작해, 센서와 통신해서 읽어온 위의 배열을 전달합니다.

이 때, `Checksum` 값과 나머지 4바이트의 합을 비교하는데 이를 통해서 오류가 난 값인지 아닌지 모듈 쪽에서 확인하고 오류가 없는 경우에만 유저 레벨 프로그램이 read 할 수 있도록 했습니다.
